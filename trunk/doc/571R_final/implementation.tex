\subsection{Implemenation}
\label{sec:implementation}

The largest part of the development infrastructure is ready. This includes a graph file format, graph parser, unit tests, makefiles, code review tool, and code repository. More importantly, we implemented three graph algorithms on the GPU: breadth-first search, single source shortest path, and PageRank. The rest of this section discusses the graph data structure we used, and the implementation of each of the aforementioned algorithms. Note that, for all algorithms, we omit several implementation details (e.g., memory transfers) and we assume that the graph fits GPU memory.

\textbf{Graph data structure.} A graph $G(V,E)$ is represented as an adjacency list by two arrays: vertices and edges. The vertices array stores for each vertex the start position in the edges array of a vertex's outgoing edges. The edges array stores the destination vertices of the outgoing edges. This is a common data structure to represent graphs, and was used in other related work~\cite{Harish2007, Sungpack2010}.

{\bf Breadth-First Search.} Breadth-first search (BFS) traverses the graph in levels given a source vertex; once a level is visited, none of the vertices in that level is visited again. Listing \ref{lst:bfs} presents the implementation of BFS where the goal of transversal search is calculating the distance from a source vertex to every other vertex in the graph; such distances are stored in the cost array. Lines $1-9$ show the function that executes on the CPU: for each level in the graph, it calls the \texttt{bfskernel} to process the vertices in the current level.


\begin{lstlisting}[caption=Breadth-First Search Implementation,label=lst:bfs]
__host__ int*
bfs_gpu(int source_id, graph* g) {
  ...
  for (int level = 0; !finished; level++) {
    finished = true;
    launch_bfs_kernel(g, level, &finished, cost);
  }
  ...
}

__kernel__void
bfs_kernel(graph* g, int level, bool* finished,
           int* cost) {
  int v_id = THREAD_GLOBAL_INDEX;
  if (v_id >= g.vertex_count) return;
  if (cost[v_id] != level) return;

  for (int i = g.vertices[v_id]; 
       i < graph.vertices[v_id + 1]; i++) {
    int nghbr = graph.edges[i];
    if (cost[nghbr] == INF) {
      *finished = false;
      cost[nghbr] = level + 1;
    }
  } // for
}
\end{lstlisting}

Each GPU thread processes a vertex. An integer array, \texttt{cost}, stores the minimal number of edges from the source vertex to each edge. The cost for vertices that have not been visited yet is infinity (INF). In each iteration, each thread checks if its vertex belongs to the current level by verifying the cost in the \texttt{cost} array (line 16). If true, it updates the costs of its not yet visited neighbors (lines $18-25$). If the cost of at least one neighbor is updated, the variable \texttt{finished} is set to \texttt{false} and there will be another iteration. Note that threads may update \texttt{finished} at the same position in the \texttt{cost} array concurrently. Such concurrent access may impact the performance of the implementation, but it does not affect correctness since all threads update the memory with the same value. The iterations are repeated until all the levels are visited.

{\bf Single Source Shortest Path.} In this work, we consider Dijkstra's algorithm that computes the single source shortest paths. Given a weighted undirected graph $G = (V, E, w)$ and a source node $s \in V$, the algorithm computes the distances from $s$ to every other node in the graph. Listing~\ref{lst:sssp} provides our current {\sc cuda} implementation based on the Dijkstra's algorithm in Harish et al.~\cite{Harish2007}.


\begin{lstlisting}[caption=GPU implementation of Single Source Shortest Path algorithm,label=lst:sssp]
__kernel__
void dijkstra_kernel(graph_t g, bool* mask, 
                     int* distances, 
                     int* new_distances) {
  const int v_id = THREAD_GLOBAL_INDEX;
  if (v_id >= g.vertex_count || !mask[v_id]) {
    return;
  }
  mask[v_id] = false;

  int my_dist = distances[v_id];
  for (int i = g.vertices[v_id]; 
       i < g.vertices[v_id + 1]; i++) {
    int nghbr = graph.edges[i];
    int* new_dist = &(new_distances[nghbr]);
    int cur_dist = my_dist + g.weights[nghbr];
    // avoid race condition
    *new_dist = atomicMin(*new_dist, cur_dist);
  } // for
}
\end{lstlisting}

{\bf PageRank.} Listing \ref{lst:pagerank} presents the implementation of PageRank. For each round, every vertex broadcasts its tentative PageRank divided by the number of outgoing edges. The tentative PageRank of a vertex is calculated as follows: the vertex sums up the value broadcasted by each of its neighbors and sets its own tentative PageRank to $((1 - d) / vertex\_count + d * sum$, where $d$ is the damping factor\footnote{A probability that models the behavior of the random surfer when she moves from one page to another without following the links on the current page.}. Broadcasting messages over outgoing edges is done as follows: the value is placed in the outbox buffer. In the next round, the inbox and outbox buffers are swapped, and the message will be accessed in the next round via the inbox buffer. This operation simulates a broadcast because all the neighbors of vertex $v$ will access the same location (i.e., \texttt{inbox[v]}) to get the message. In the last round, the outbox will contain the PageRank of each vertex. Note that for PageRank, we assume that the edges array stores the incoming edges rather than the outgoing edges.

\begin{lstlisting}[caption=GPU implementation of PageRank,label=lst:pagerank]
__host__ float* 
page_rank_gpu(graph_t* g) {
  ...
  for (int round = 0; round < MAX_ROUNDS;
       round++) {
    // simulate message passing
    float* tmp = in_d;
    in_d = out_d;
    out_d = tmp;
    bool finished = (round == (MAX_ROUNDS - 1));
    launch_page_rank_kernel(g, in_d, out_d,
                            finished);
  }
  ...
}

__kernel__
page_rank_kernel(graph_t g, float* in, 
                 float* out, bool finished) {
  id_t v_id = THREAD_INDEX;
  if (v_id >= g.vertex_count) return;
  // sum the rank of all neighbors
  double sum = 0;
  for (int i = g.vertices[v_id]; 
       i < g.vertices[v_id + 1]; i++) {
    int nghbr = g.edges[i];
    sum += in[nghbr];
  }
  // calculate my rank
  float rank = ((1 - d) / g.vertex_count) +
               (d * sum);
  out[v_id] = finished ?
              rank : rank / nbrs_count;
}
\end{lstlisting}

